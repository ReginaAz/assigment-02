## Условия практики

### Общая информация

1. Если требуется реализовать функцию, которая принимает некоторые аргументы и возвращает некоторое новое значение,
   **она не должна менять значения переданных в нее аргументов**.
2. Иногда будет в явном виде написано, что от вас требуется реализовать функцию, которая изменяет переданные в нее
   аргументы.

---

3. Если практика окажется большой по объему, задания с практики тоже будут оцениваться баллами и их можно\нужно будет
   доделать дома.

### [data.py](data.py)

---

> `censor(s: str, blacklist: list[str]) -> str`

Реализуйте функцию, принимающую строку и список запрещенных подстрок, и возвращающую результат замены всех запрещенных
подстрок на соответствующее их длине число `'*'`.

*Примеры*:

* `censor('Hello world!', ['world'])` &rightarrow; `'Hello, *****!'`
* `censor('I am inevitable', ['I', 'inevi'])` &rightarrow; `'* am *****table'`

*Гарантируется, что вхождения запрещенных подстрок не пересекаются.*

---

> `shorten(s: str, size: int) -> str`

Реализуйте функцию, принимающую строку и длину, до которой ее надо укоротить. Функция должна вернуть новую строку длины
ровно `size`, которая получается из строки `s`:

1. переводом в нижний регистр
2. заменой всех пробелов на прочерк `'-'`
3. при длине строки `s` больше `size` &ndash; заменой середины строки на `'..'` или `'...'`
   в зависимости от четности `size`

*Примеры*:

* `shorten('World', 4)` &rightarrow; `'w..d'`
* `shorten('Task number 1 Data', 15)` &rightarrow; `'task-n...1-data'`

*Гарантируется, что `size > 3` и в исходной строке встречаются только буквы латинского алфавита, цифры и пробелы.*

---

> `windowed_average(array: list[Number], k: int) -> list[float]`

Реализуйте функцию, которая принимает массив чисел `array` и натуральное число `k`, и возвращает средние арифметические
элементов массива `array` на всех подотрезках длины `k`.

*Примеры*:

* `windowed_average([1, 3, 5, 7, 9], 2)` &rightarrow; `[2.0, 4.0, 6.0, 8.0]`
* `windowed_average([1, 5, 7, 10, 18], 4)` &rightarrow; `[5.75, 10.0]`

**Дополнительный балл тем, чье решение будет работать меньше секунды при `len(array) = 2 * k = 100000`**.

---

> `shuffle(array: list, times: int) -> list`

Реализуйте функцию, &laquo;перемешивающую&raquo; копию массива `array` как колоду карт `times` раз. Каждое перемешивание
заключается в

1. разбиении массива на две половины (в случае нечетной длины левая половина должна иметь размер на 1 меньше)
   > `[1, 2, 3, 4, 5]` &rightarrow; `[1, 2]`, `[3, 4, 5]`
2. объединении двух половин в одну последовательным выбором элементов слева-направо, начиная со второй половины
   > `[1, 2]`, `[3, 4, 5]` &rightarrow; `[3, 1, 4, 2, 5]`

*Примеры*:

* `shuffle([1, 2, 3, 4, 5], 1)` &rightarrow; `[3, 1, 4, 2, 5]`
* `shuffle([1], 100)` &rightarrow; `[1]`
* `shuffle([1, 2, 3, 4], 3)` &rightarrow; `[2, 4, 1, 3]`

---

> `is_unrestricted(item: Any) -> bool`

Реализуйте функцию, проверяющую, может ли `item` являться элементом множества (`set`).

*Примеры*:

* `is_unrestricted([])` &rightarrow; `False`
* `is_unrestricted((1, 2, (3, 4)))` &rightarrow; `True`
* `is_unrestricted(357235)` &rightarrow; `True`
* `is_unrestricted("112")` &rightarrow; `True`
* `is_unrestricted((1, 2, {3, 4}))` &rightarrow; `False`

*Подсказка*: вам может быть полезна встроенная функция `hash()`.

---

> `update_squares(s: set[Number])`

Реализуйте функцию, которая принимает множество чисел `s`, и добавляет в него квадрат каждого числа, которое в нем было
на момент вызова функции. Возвращать из функции ничего не требуется, **необходимо изменить то множество, которое было
передано в качестве аргумента**.

*Примеры*:

* `update_squares(s = {1, 2, 3})` &rightarrow; `s` стало равно `{1, 2, 3, 4, 9}`
* `update_squares(s = {-1, 1})` &rightarrow; `s` стало равно `{-1, 1}`
* `update_sqaures(s = {2, 4, 16})` &rightarrow; `s` стало равно `{2, 4, 16, 256}`

---

> `select(d: dict, *args) -> dict`

Реализуйте функцию, которая принимает словарь `d` и произвольное число позиционных аргументов, после чего возвращает
новый словарь, множество ключей которого совпадает с `args`, и тем ключам, которые присутствовали в `d`, соответствуют
те же значения, что и в `d`, а остальным &ndash; `None`.

*Примеры*:

* `select({'name': 'Barsik', 'age': 10, 'job': 'Cat'}, 'name', 'age')` &rightarrow; `{'name': 'Barsik', 'age': 10}`
* `select({'name': 'Barsik', 'job': 'Cat'}, 'name', 'age')` &rightarrow; `{'name': 'Barsik', 'age': None}`
* `select({}, 'x', 'y', 'x')` &rightarrow; `{'x': None, 'y': None, 'z': None}`

### [functions.py](functions.py)

---

> `rprint(array: list, max_depth: int)`

Реализуйте функцию, которая принимает массив (элементами которого могут являться такие же вложенные массивы) и выводит
его с точностью до глубины `max_depth`, на которой все более вложенные элементы заменяются на `'...'`.

*Примеры*:

* `rprint([1, [2], [[3]], [[[4]]]], 2)` печатает `[1, [2], [[...]], [[...]]]`
* `rprint([1, [2, 3], [[4, [5], [6, [7], [[[8]]]]]], [9]], 3)` печатает `[1, [2, 3], [[4, [...], [...]]], [9]]`
* `rprint([1, 2, 3], 0)` печатает `[...]`

---

> `median(*args: int, low: bool) -> int`

Реализуйте функцию, находящую медиану из всех переданных в нее аргументов. Функция так же должна поддерживать
опциональный именной аргумент `low`, указывающий, какой из двух центральных аргументов считать медианой, если их
четное число.

*Примеры*:

* `median(4, 3, 5, 1, 2)` &rightarrow; `3`
* `median(6, 2, 1, 4, 5, 3)` &rightarrow; `3`
* `median(6, 2, 1, 4, 5, 3, low=False)` &rightarrow; `4`

---

> `sequential_replace(s: str, **kwargs: dict[str, str]) -> str`

Реализуйте функцию, которая заменяет в строке все вхождения ключей из `kwargs` на соответствующие им значения.
Гарантируется, что вхождения ключей в исходную строку не пересекаются, то есть что от порядка выполнения замен результат
не зависит. **При этом** после замены одного из ключей, может появиться новое вхождение другого &ndash; такие вхождения
не надо учитывать (см примеры)!

*Примеры*:

* `sequential_replace('i am a cat', i='you', am='are', cat='human')` &rightarrow; `'you are a human'`
* `sequential_replace('defeat is not an option', defeat='option', option='defeat', an='a')`
  &rightarrow; `'option is not a defeat'`
* `sequential_replace('subwords can also be replaced', sub='', laced='eated')`
  &rightarrow; `'words can also be repeated'`

---

> `signature(...)`

Задайте функцию таким образом, чтобы она

1. принимала от одного до трех **строго позиционных** аргументов `a`, `b` и `c`: для этого надо
    * сделать их строго позиционными и
    * сделать два из них имеющими значения по умолчанию
2. принимала позиционный или именной аргумент `start`, имеющий значение по умолчанию `0`
3. принимала обязательный **строго именной** аргумент `mode`
4. принимала опциональный **строго именной** аргумент `inplace` со значением по умолчанию `False`

Тело функции не должно меняться и должно состоять только из слова `pass`.

*Примеры*:

* `signature(1, mode='print')` &ndash; OK
* `signature(1, 2, 3, mode='precalc', inplace=True)` &ndash; OK
* `signature(1, 2, 3, start=0, mode='print', inplace=False)` &ndash; OK
* `signature(1, 2, 3, 0, mode='print')` &ndash; OK
* `signature(1)` &ndash; FAIL (не указан `mode`)
* `signature(mode='print')` &ndash; FAIL (не передан ни один позиционный аргумент)
* `signature(a=1, b=2, start=3, mode='precalc')` &ndash; FAIL (`a`, `b` и `c` должны быть позиционными)
* `signature(1, 2, 3, 0, 'print')` &ndash; FAIL (`mode` можно передавать только по имени)

---

> `twice(f: Callable) -> Callable`

Реализуйте функцию, которая оборачивает переданную в нее функцию `f`, чтобы та применялась дважды. Иными
словами, вы должны вернуть новую функцию `g` такую, что `g(x) == f(f(x))` для любого `x`.
Гарантируется, что `f` &ndash; функция от одного аргумента.

*Примеры*:

* для `f(x) = x + 2`, `g = twice(f)` при применении к `x` должна возвращать `g(x) = x + 4`
* для `f(x) = x ** 2`, `g = twice(f)` при применении к `x` должна возвращать `g(x) = x ** 4`
* для `f(x): print(x); return x`, `g = twice(f)` при применении к `x` должна дважды печатать `x` и возвращать `x`

---

> `logging(f: Callable) -> Callable`

Реализуйте функцию, которая оборачивает переданную в нее функцию `f`, и возвращает новую функцию (`_invoke`), которая
ведет себя полностью идентично `f`, возвращает те же самые значения, но при этом перед каждым вызовом выводит все
переданные в нее аргументы.

*Пример:*

```python
def f(x, y, z, opt=False):
    if opt:
        return max(x, y, z)
    return min(x, y, z)


g = logging(f)
x = g(1, 2, 3, opt=True)
y = g(6, 5, 4)
```

должно записать `x = 3`, `y = 4`, и напечатать

```
> (1, 2, 3), {'opt': True}
> (6, 5, 4), {}
```