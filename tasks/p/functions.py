from typing import Callable


# RECURSION

def rprint(array: list, max_depth: int = -1):
    """
    Функция принимает массив со вложенными массивами и выводит его с точностью
    до глубины max_depth, заменяя все более глубокие элементы на '...'
    """

    def _worker(obj, depth: int):
        ...

    print(_worker(array, 0))


# ARGS, KWARGS

def median(*args, low: bool = True):
    """
    Функция принимает произвольное число аргументов и возвращает медиану
    (если low = True, то при четном числе элементов возвращается меньшая из
    двух медиан, иначе - большая)
    """
    ...


def sequential_replace(s: str, **kwargs: dict[str, str]):
    """
    Функция принимает строку s и набор аргументов вида key=value и возвращает
    строку s, в которой все вхождения подстрок key заменены на подстроки value
    (гарантируется, что все вхождения ключей в s не пересекаются)
    """
    ...


def signature():
    """
    Функция должна иметь возможность быть вызванной только указанным в условии
    образом (при этом не должна что-либо делать)
    """
    pass


# HIGH ORDER

def twice(f: Callable):
    """
    Функция принимает другую функцию от одного аргумента f и возвращает новую
    функцию от одного аргумента, выполняющую двойное применение f
    (например, при f(x) -> x + 5 и g = twice(f), верно g(x) -> x + 10)
    """
    ...


def logging(f: Callable):
    """
    Функция принимает другую функцию от произвольного набора аргументов f и
    возвращает новую функцию, которая копирует поведение f, но перед каждым
    вызовом выводит все переданные в нее аргументы
    """

    def _invoke(*args, **kwargs):
        ...

    return _invoke
