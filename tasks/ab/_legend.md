## Условия ДЗ

### Общая информация

1. Если требуется реализовать функцию, которая принимает некоторые аргументы и возвращает некоторое новое значение,
   **она не должна менять значения переданных в нее аргументов**.
2. Иногда будет в явном виде написано, что от вас требуется реализовать функцию, которая изменяет переданные в нее
   аргументы.

#### Базовая и продвинутая версия

В этот раз не будет базовой и продвинутой версии, при этом максимальный балл, который можно получить за это ДЗ,
равен 1.2.

### [data.py](data.py)

---

> `wordcount(s: str) -> dict[str, int]`

Реализуйте функцию, принимающую строку, состоящую из слов (последовательностей маленьких латинских букв), разделенных
пробелами, и возвращающую словарь, который сопоставляет слова и количество их вхождений в эту строку.

*Примеры*:

* `wordcount('hello world hello')` &rightarrow; `{'hello': 2, 'world': 1}`
* `wordcount('')` &rightarrow; `{}`
* `wordcount('i am who i am')` &rightarrow; `{'i': 2, 'am': 2, 'who': 1}`

---

> `caesar_encode(s: str, shift: int) -> str`

Реализуйте функцию, выполняющую кодирование шифром Цезаря строки `s` с заданным сдвигом `shift` влево. Иными словами,
каждую букву в строке следует заменить на предшествующую ей на `shift` позиций в алфавите по циклу.

*Примеры*:

* `caesar_encode('caesar', 1)` &rightarrow; `'bzdrzq'`
* `caesar_encode('Encode this', 11)` &rightarrow; `'Tcrdst iwxh'`

*Подсказка*: используйте функции `ord()` и `chr()`.

---

> `caesar_decode(s: str, shift: int) -> str`

Реализуйте функцию, выполняющую обратное преобразование к предыдущей, то есть декодирующую строку, зашифрованную с
помощью шифра Цезаря со сдвигом `shift` влево.

**Реализация вашей функции должна состоять из вызова `caesar_encode()` и больше ничего.**

* `caesar_encode('bzdrzq', 1)` &rightarrow; `'caesar'`
* `caesar_encode('Tcrdst iwxh', 11)` &rightarrow; `'Encode this'`

---

> `extract_each(array: list, k: int, cyclic: bool) -> list`

Реализуйте функцию, которая возвращает массив, состоящий из каждого `k`-го элемента массива `array`, начиная с нулевого.
Если при этом значение параметра `cyclic` равно `True`, то при достижении конца массива следует продолжать выбирать
элементы, как если бы массив был зациклен (после последнего элемента следовал бы нулевой). Остановиться в таком случае
надо перед элементом, который уже был положен в ответ.

*Примеры*:

* `extract_each([1, 2, 3, 4], 1)` &rightarrow; `[1, 2, 3, 4]`
* `extract_each([1, 2, 3, 4], 3)` &rightarrow; `[1, 4]`
* `extract_each([1, 2, 3, 4], 3, True)` &rightarrow; `[1, 4, 3, 2]`

---

> `compare(s1: set[int], s2: set[int]) -> bool`

Реализуйте функцию "сравнения" на меньше\больше\равно между двумя множествами целых чисел. Равными считаются только
множества, состоящие из одинаковых элементов. Если множества отличаются, то меньшим считается

* меньшее по размеру, если одно является подмножеством другого
* содержащее меньший из элементов, не представленных в другом множестве

Верните `True`, если `s1` строго меньше `s2`, и `False` иначе.

*Примеры*:

* `compare({1, 2, 3}, {1, 2, 3})` &rightarrow; `False`
* `compare({1, 2}, {1, 2, 3})` &rightarrow; `True`
* `compare({1, 2, 4}, {1, 2, 5})` &rightarrow; `True`

---

> `merge(d1: dict, d2: dict, recursive: bool) -> dict`

Реализуйте функцию, которая объединяет два словаря. В возвращаемом словаре должны присутствовать все ключи, которые
присутствуют в `d1` или в `d2`, при чем

* если ключ есть только в `d1`, то соответствующее ему значение должно быть равно значению в `d1`
* аналогично для `d2`
* если ключ есть в обоих словарях, то
    * при `recursive = False` или хотя бы одном значении не типа `dict` достаточно оставить значение из первого словаря
    * при `recursive = True` соответствующие значения надо так же слить с помощью `merge`

*Примеры*:

* `merge({'x': 10}, {'y': 20})` &rightarrow; `{'x': 10, 'y': 20}`
* `merge({'x': 10}, {'x': 20})` &rightarrow; `{'x': 10}`
* `merge({'x': {'y': 20}}, {'x': {'z': 30}})` &rightarrow; `{'x': {'y': 20}}`
* `merge({'x': {'y': 20}}, {'x': {'z': 30}}, True)` &rightarrow; `{'x': {'y': 20, 'z': 30}}`

**Решения, верно работающие при `recursive = False`, получают 1 балл, при `recursive = True` &ndash; еще плюс 1 балл.**

---

> `translate_back(d: dict[str, list[str]])`

Реализуйте функцию, которая по словарю перевода с одного языка на другой строит словарь перевода в обратную сторону.
Более формально, для каждого слова заданы возможные способы его перевода, и для обратного перевода должно выполняться,
что для каждого `value`, лежащего в `d[key]`, сам `key` должен лежать в `result[value]`.

*Пример*:

```python
translate_back({
    'apple': ['malum', 'pomum', 'popula'],
    'fruit': ['popum'],
    'punishment': ['malum', 'multa']
})
```

&rightarrow;

```python
{
    'malum': ['apple', 'punishment'],
    'pomum': ['apple'],
    'popula': ['apple'],
    'popum': ['fruit'],
    'multa': ['punishment']
}
```

### [functions.py](functions.py)

---

> `useless_function()`

Сделайте так, чтобы эта функция ничего не возвращала и ничего не делала, при этом не стирая и не комментируя уже
имеющийся в ней код.

---

> `print_tree(size: int)`

Реализуйте функцию, которая "рисует" звездочками в выводе елку из `size` треугольных сегментов с высотами от `1` до
`size`.

*Примеры*:

<details>
<summary>
"Елочка" высоты 3:
</summary>

```
  *  
  *  
 *** 
  *  
 *** 
*****
```

</details>

<details>
<summary>
"Елочка" высоты 5:
</summary>

```
    *  
    *  
   *** 
    *  
   *** 
  *****
    *  
   *** 
  *****
 *******
    *  
   *** 
  *****
 *******
*********
```

</details>

---

> `generate_json(depth: int) -> dict`

Реализуйте функцию, которая генерирует случайный словарь, в котором ключами могут быть произвольные строки, а значениями
&ndash; числа, строки и словари такой же структуры, при чем

* уровень вложенности словарей должен быть ровно `depth`
* в каждом непустом словаре должно быть хотя бы три ключа

*Пример*:

```python
generate_json(3)
```

&rightarrow;

```python
{
    'number': 1,
    'string': 'qwerty',
    'data': {
        'key1': 1,
        'key2': '2',
        'config': {
            'file': 'conf/conf.yaml',
            'lang': 'python',
            'version': '3.9'
        }
    }
}
```

---

> `wtf() -> 42`

Подставьте число во внутренний вызов функции `_worker()`, чтобы функция `wtf()` возвращала число 42. Для этого
проанализируйте поведение внутренней функции `_worker()` и поймите, какой параметр в нее надо передавать, чтобы она
возвращала ровно это число.

**Менять любой другой код внутри этой функции запрещено.**

---

> `mex(*args: int) -> int`

Реализуйте функцию, которая находит минимальное целое неотрицательное число, которого нет среди переданных в нее
аргументов (mex = minimal excluded).

*Примеры*:

* `mex(1, 5, 3, 0, 2, 6)` &rightarrow; `4`
* `mex(1, 2, 3, 4)` &rightarrow; `0`

---

> `replace_keys(data: dict[str, Any], **kwargs: str) -> dict[str, Any]`

Реализуйте функцию, которая возвращает словарь, отличающийся от переданного `data` заменой ключей в соответствии с
переданными `**kwargs`. Для каждой пары `key1: key2` в именных аргументах, если в `data` есть ключ `key1`, то в
результирующем словаре соответствующее ему значение должно лежать вместо этого под ключом `key2`.

*Примеры*:

* `replace_keys({'x': 1, 'y': 2}, x='z')` &rightarrow; `{'z': 1, 'y': 2}`
* `replace_keys({'x': 1, 'y': 2, 'z': 3}, x='y', y='z', z='x', p='q')` &rightarrow; `{'y': 1, 'z': 2, 'x': 3}`

---

> `count_calls_until(f: Callable, start, condition: Callable[..., bool]) -> int`

Реализуйте функцию, которая считает и возвращает количество раз, которое требуется применить функцию `f` к
значению `start`, чтобы для результата начало выполняться условие `condition`.

*Примеры*:

<details>
<summary>
Сколько раз надо увеличить 0 на 2, чтобы полученное число стало больше 10? Ответ: 6.
</summary>

```python
count_calls_until(
    lambda x: x + 2,
    0,
    lambda x: x > 10
)
```

</details>

<details>
<summary>
Сколько раз надо поделить 1257513 на 10, чтобы получить 0? Ответ: 7.
</summary>

```python
count_calls_until(
    lambda x: x // 10,
    1257513,
    lambda x: x == 0
)
```

</details>

---

> `bind(f: Callable, **kwargs) -> Callable`

Реализуйте функцию, которая "пред-подставляет" в функцию `f` некоторые позиционные аргументы перед ее вызовом. Каждый
передаваемый аргумент имеет вид `_n = value` и означает, что в качестве `n`-го позиционного аргумента следует
подставлять значение `value` (см. примеры).

*Пример*:

```python
def f(x, y):
    return x - y

fx = bind(f, _1=10)  # эквивалентно функции fx(y): return 10 - y
print(fx(1), fx(10), fx(15))  # 9, 0, -5

fy = bind(f, _2=10)  # эквивалентно функции fy(x): return x - 10
print(fy(7), fy(11), fy(13))  # -3, 1, 3

fxy = bind(f, _1=22, _2=31)  # эквивалентно функции fxy(): return 22 - 31
print(fxy())  # -9
```